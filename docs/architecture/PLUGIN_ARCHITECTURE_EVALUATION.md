# Plugin Architecture Evaluation

## Executive Summary

This document evaluates the proposal to simplify the plugin architecture by having the **frontend declare which plugins it has**, with the **backend only storing enabled/disabled state and settings**. The backend would handle integration API proxying through a render/integration method.

## Current Architecture Analysis

### What the Backend Currently Does

```
┌─────────────────────────────────────────────────────────────────┐
│                    Backend Plugin System                         │
├─────────────────────────────────────────────────────────────────┤
│  1. Discovery (PluginLoader)                                     │
│     - Scans filesystem for plugin.yaml, theme.yaml, etc.        │
│     - Validates manifest (id format, semver, required fields)   │
│     - Caches Plugin instances in memory                         │
│                                                                  │
│  2. Manifest Serving (Views API, Themes API)                    │
│     - GET /api/v1/views → returns view metadata from manifests  │
│     - GET /api/v1/themes → returns theme metadata               │
│     - GET /api/v1/themes/{id}/stylesheet → streams CSS files    │
│                                                                  │
│  3. Integration Execution (IntegrationExecutor)                 │
│     - Proxies API calls through backend (keeps secrets safe)    │
│     - Parameter binding from config                             │
│     - Auth header injection (Bearer/API-Key)                    │
│                                                                  │
│  4. Configuration Storage (Database)                            │
│     - PluginConfig: workspace-level enabled + config            │
│     - NotebookPluginConfig: notebook-level overrides            │
│     - PluginSecret: encrypted API keys                          │
└─────────────────────────────────────────────────────────────────┘
```

### What the Frontend Currently Does

```
┌─────────────────────────────────────────────────────────────────┐
│                   Frontend Plugin System                         │
├─────────────────────────────────────────────────────────────────┤
│  1. Component Registration (viewPluginService.ts)               │
│     - Registers built-in view components statically             │
│     - Maps view IDs → lazy-loaded Vue components                │
│                                                                  │
│  2. Discovery via API                                            │
│     - Fetches GET /api/v1/views to get available views          │
│     - Stores metadata in memory                                  │
│                                                                  │
│  3. Plugin Block Loading (pluginLoader.ts)                      │
│     - Loads pre-built Vue components from /plugins/dist/        │
│     - Uses components.json manifest (generated by build script) │
│     - Falls back gracefully if components not found             │
└─────────────────────────────────────────────────────────────────┘
```

## Proposed Architecture

### Core Principle

> "The frontend declares which plugins it has, and the backend just needs to store enabled/disabled and settings at both the notebook/workspace level."

### What This Means

```
┌─────────────────────────────────────────────────────────────────┐
│                   Proposed: Frontend-Led Plugins                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Frontend                          Backend                       │
│  ────────                          ───────                       │
│  ┌──────────────────┐              ┌────────────────────────┐   │
│  │ Plugin Registry  │───register──▶│ POST /plugins/register │   │
│  │ (built-in list)  │              │ - Stores manifest in DB │   │
│  └──────────────────┘              │ - Caches for API proxy  │   │
│          │                         └────────────────────────┘   │
│          │                                    │                  │
│          │                                    ▼                  │
│          │                         ┌────────────────────────┐   │
│          │                         │ Plugin State Storage    │   │
│          │                         │ - enabled/disabled      │   │
│          │                         │ - workspace settings    │   │
│          │                         │ - notebook overrides    │   │
│          │                         │ - encrypted secrets     │   │
│          │                         └────────────────────────┘   │
│          │                                    │                  │
│          ▼                                    ▼                  │
│  ┌──────────────────┐              ┌────────────────────────┐   │
│  │ Vue Components   │              │ Integration Executor    │   │
│  │ (render locally) │◀───data─────│ - Proxy API calls       │   │
│  └──────────────────┘              │ - Return cached data    │   │
│                                    └────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Detailed Evaluation

### What Can Be Removed from Backend

| Current Component | Can Remove? | Notes |
|-------------------|-------------|-------|
| `PluginLoader.discover_plugins()` | ✅ Yes | Frontend declares what exists |
| `PluginLoader.load_plugin()` | ✅ Yes | Frontend sends manifest on init |
| Filesystem scanning | ✅ Yes | No need to scan plugins/ dir |
| Manifest validation | ⚠️ Partial | Could move to frontend or keep as API validation |
| `GET /api/v1/views` | ✅ Yes | Frontend already knows its views |
| `GET /api/v1/themes` | ✅ Yes | Frontend already knows its themes |

### What Must Remain in Backend

| Component | Reason |
|-----------|--------|
| Configuration storage | Database access required |
| Enable/disable state | Multi-user, persistent |
| Secret storage | Security - API keys must not be in frontend |
| Integration executor | Security - proxies API calls with secrets |
| Rate limiting/logging | Track API usage per workspace |

### New Components Needed

#### 1. Plugin Registration Endpoint

```python
# POST /api/v1/plugins/register
class PluginRegistrationRequest(BaseModel):
    id: str
    name: str
    version: str
    type: str  # "view" | "theme" | "integration"
    manifest: dict  # Full manifest for integrations

@router.post("/register")
async def register_plugin(
    request: PluginRegistrationRequest,
    session: AsyncSession = Depends(get_system_session),
):
    """Frontend registers plugins it knows about.

    For integrations, stores manifest for API proxying.
    For views/themes, just acknowledges existence.
    """
    # Upsert into plugins table
    # For integrations: cache manifest for executor use
    pass
```

#### 2. Integration Render Method

```python
# POST /api/v1/integrations/{id}/render
class RenderRequest(BaseModel):
    block_type: str
    parameters: dict
    use_cache: bool = True

@router.post("/{integration_id}/render")
async def render_integration_block(
    integration_id: str,
    workspace_id: int,
    request: RenderRequest,
    ...
):
    """Render an integration block.

    1. Check cache for pre-fetched data
    2. If cache miss or stale, execute API call
    3. Return data for frontend rendering
    4. Optionally store artifacts
    """
    # Check artifact cache
    cached = await get_cached_artifact(workspace_id, integration_id, request.block_type)
    if cached and request.use_cache:
        return cached

    # Execute API and cache result
    result = await executor.execute_endpoint(...)
    await cache_artifact(workspace_id, integration_id, request.block_type, result)
    return result
```

## Architecture Comparison

### Current Architecture

```
Pros:
+ Backend is self-documenting (can query for available plugins)
+ Plugin discovery is automatic
+ Single source of truth for what plugins exist

Cons:
- Requires plugins directory on backend filesystem
- Backend must understand all manifest formats
- Duplicated plugin awareness (frontend has components, backend has manifests)
- Changes to plugins require backend restart
```

### Proposed Architecture

```
Pros:
+ Frontend is authoritative for what UI plugins exist
+ Backend is simpler - just storage and API proxy
+ Can add new view/theme plugins without touching backend
+ Better separation of concerns
+ Easier to deploy (frontend ships with all UI knowledge)

Cons:
- Frontend must initialize/register plugins on startup
- Backend loses discoverability (can't query "what plugins exist?")
- Integration manifests still need to reach backend for API proxying
```

## Recommended Implementation

### Phase 1: Minimal Changes

Keep the database schema as-is. Change the flow:

1. **Frontend declares available plugins** via `POST /api/v1/plugins/register`
2. **Backend stores plugin metadata** in existing `plugins` table
3. **Backend removes filesystem scanning** - uses DB as source of truth
4. **Integration manifests** stored in DB, not loaded from filesystem

```python
# New plugin model with manifest storage
class Plugin(SQLModel, table=True):
    id: int = Field(default=None, primary_key=True)
    plugin_id: str = Field(unique=True, index=True)
    name: str
    version: str
    type: str
    manifest: dict = Field(default_factory=dict, sa_type=JSON)  # Full manifest
    registered_at: datetime = Field(default_factory=datetime.utcnow)
```

### Phase 2: Integration Caching/Artifacts

Add artifact caching for integration API responses:

```python
class IntegrationArtifact(SQLModel, table=True):
    """Cached API responses for integration blocks."""
    id: int = Field(default=None, primary_key=True)
    workspace_id: int = Field(foreign_key="workspace.id")
    plugin_id: str
    block_type: str
    parameters_hash: str  # Hash of request parameters
    data: dict = Field(sa_type=JSON)
    fetched_at: datetime
    expires_at: datetime | None = None
```

### Phase 3: Pre-fetch Scheduling

Allow integrations to define refresh schedules:

```yaml
# integration.yaml
blocks:
  - id: weather
    refresh_interval: 3600  # seconds
    pre_fetch: true  # Backend fetches on schedule
```

## API Changes Summary

### Remove

```
GET /api/v1/views       # Frontend knows its own views
GET /api/v1/themes      # Frontend knows its own themes
```

### Keep

```
GET  /api/v1/integrations                    # List registered integrations
GET  /api/v1/integrations/{id}               # Get integration details
PUT  /api/v1/integrations/{id}/enable        # Enable/disable
GET  /api/v1/integrations/{id}/config        # Get config
PUT  /api/v1/integrations/{id}/config        # Update config
POST /api/v1/integrations/{id}/test          # Test connection
POST /api/v1/integrations/{id}/execute       # Execute endpoint
```

### Add

```
POST /api/v1/plugins/register                # Register plugin from frontend
POST /api/v1/plugins/register-batch          # Register multiple plugins
POST /api/v1/integrations/{id}/render        # Render with caching
GET  /api/v1/plugins/{id}/artifacts          # Get cached artifacts
```

## Migration Path

1. **Add registration endpoint** - frontend can start using it
2. **Modify frontend** to call registration on app init
3. **Remove `PluginLoader.discover_plugins()`** - use DB instead
4. **Keep manifest in DB** for integration execution
5. **Add render endpoint** with caching
6. **Remove theme/view APIs** - frontend handles locally

## Configuration Storage (No Changes Needed)

The existing schema already supports the proposed architecture:

```sql
-- Workspace-level config (already exists)
plugin_configs (workspace_id, plugin_id, enabled, config)

-- Notebook-level overrides (already exists)
notebook_plugin_configs (notebook_id, plugin_id, enabled, config)

-- Secrets (already exists)
plugin_secrets (workspace_id, plugin_id, key, encrypted_value)
```

## Conclusion

The proposed architecture is sound and represents a cleaner separation of concerns:

- **Frontend** owns UI plugin knowledge (views, themes, block components)
- **Backend** owns state (enabled/disabled, config, secrets) and API proxying

The main work is:
1. Add `POST /api/v1/plugins/register` endpoint
2. Store integration manifests in DB instead of filesystem
3. Add `POST /api/v1/integrations/{id}/render` with caching
4. Remove `PluginLoader` filesystem scanning
5. Update frontend to register plugins on startup

This simplifies deployment (no plugins directory needed on backend) and makes the system more flexible for adding new UI plugins without backend changes.
