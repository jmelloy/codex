/**
 * Plugin Component Loader
 *
 * Loads pre-built Vue components from the plugins directory.
 * Components are built by the plugin build script (plugins/build.ts)
 * and output to plugins/{plugin}/dist/{component}.js
 */

import { defineAsyncComponent, h, type Component } from "vue"

// Component manifest type (generated by build script)
interface ComponentManifestEntry {
  pluginId: string
  pluginName: string
  pluginVersion: string
  blockId: string
  blockName: string
  file: string
  icon?: string
  description?: string
}

interface PluginComponentManifest {
  version: string
  buildTime: string
  components: Record<string, ComponentManifestEntry>
}

// Cache for loaded manifest and components
let manifestCache: PluginComponentManifest | null = null
let manifestLoadPromise: Promise<PluginComponentManifest | null> | null = null

/**
 * Load the component manifest
 */
async function loadManifest(): Promise<PluginComponentManifest | null> {
  if (manifestCache) {
    return manifestCache
  }

  if (manifestLoadPromise) {
    return manifestLoadPromise
  }

  manifestLoadPromise = (async () => {
    try {
      // Try to load the manifest from the plugins directory
      const response = await import(
        /* @vite-ignore */ "@plugins/components.json"
      )
      manifestCache = response.default || response
      return manifestCache
    } catch (err) {
      console.warn("Plugin manifest not found. Run 'npm run build' in plugins directory.", err)
      return null
    }
  })()

  return manifestLoadPromise
}

/**
 * Create a fallback component for when plugins fail to load
 */
function createFallbackComponent(blockType: string, error?: string): Component {
  return {
    props: ["config"] as const,
    setup(props: { config?: Record<string, unknown> }) {
      return () =>
        h("div", { class: "custom-block plugin-fallback-block" }, [
          h("div", { class: "block-header" }, [
            h("span", { class: "block-icon" }, "âš ï¸"),
            h("span", { class: "block-title" }, `${blockType} Block`),
          ]),
          h("div", { class: "block-content" }, [
            h("div", { class: "block-note" }, [
              h("em", {}, error || "Plugin component not available. Run 'npm run build' in the plugins directory."),
            ]),
            props.config &&
              h(
                "pre",
                { class: "config-preview" },
                JSON.stringify(props.config, null, 2)
              ),
          ]),
        ])
    },
  }
}

/**
 * Create a loading component
 */
const LoadingComponent: Component = {
  setup() {
    return () =>
      h("div", { class: "custom-block loading-block" }, "Loading plugin...")
  },
}

/**
 * Load a plugin component by block type
 *
 * @param blockType - The block type (e.g., "weather", "link-preview")
 * @returns A Vue component (async) that renders the block
 */
export function loadPluginComponent(blockType: string): Component {
  return defineAsyncComponent({
    loader: async () => {
      // First, try to load from manifest
      const manifest = await loadManifest()

      if (manifest) {
        // Find the component in manifest
        for (const [key, entry] of Object.entries(manifest.components)) {
          if (entry.blockId === blockType) {
            // Load the compiled component
            try {
              const module = await import(
                /* @vite-ignore */ `@plugins/${entry.file}`
              )
              return module.default || module
            } catch (err) {
              console.error(`Failed to load compiled component for ${blockType}:`, err)
              // Fall through to try source file
            }
          }
        }
      }

      // Fallback: try to load from well-known locations (for development without build)
      const fallbackPaths: Record<string, string> = {
        weather: "weather-api/components/WeatherBlock.vue",
        "link-preview": "opengraph/components/LinkPreviewBlock.vue",
      }

      const fallbackPath = fallbackPaths[blockType]
      if (fallbackPath) {
        try {
          const module = await import(
            /* @vite-ignore */ `@plugins/${fallbackPath}`
          )
          return module.default || module
        } catch (err) {
          console.warn(`Failed to load fallback component for ${blockType}:`, err)
        }
      }

      // Return fallback component
      return createFallbackComponent(blockType)
    },
    errorComponent: createFallbackComponent(blockType, "Failed to load component"),
    loadingComponent: LoadingComponent,
    delay: 200,
    timeout: 10000,
  })
}

/**
 * Get all available block types from loaded plugins
 */
export async function getAvailableBlockTypes(): Promise<
  Array<{
    blockType: string
    pluginId: string
    pluginName: string
    icon?: string
    description?: string
  }>
> {
  const manifest = await loadManifest()

  if (!manifest) {
    // Return built-in block types as fallback
    return [
      {
        blockType: "weather",
        pluginId: "weather-api",
        pluginName: "Weather API Integration",
        icon: "â˜€ï¸",
        description: "Display weather information",
      },
      {
        blockType: "link-preview",
        pluginId: "opengraph",
        pluginName: "Open Graph Link Unfurling",
        icon: "ðŸ”—",
        description: "Rich link previews",
      },
    ]
  }

  return Object.values(manifest.components).map((entry) => ({
    blockType: entry.blockId,
    pluginId: entry.pluginId,
    pluginName: entry.pluginName,
    icon: entry.icon,
    description: entry.description,
  }))
}

/**
 * Check if a block type is available
 */
export async function isBlockTypeAvailable(blockType: string): Promise<boolean> {
  const manifest = await loadManifest()

  if (manifest) {
    return Object.values(manifest.components).some(
      (entry) => entry.blockId === blockType
    )
  }

  // Check built-in types
  return ["weather", "link-preview"].includes(blockType)
}

/**
 * Preload all plugin components (for faster rendering)
 */
export async function preloadPluginComponents(): Promise<void> {
  const manifest = await loadManifest()

  if (!manifest) {
    return
  }

  const loadPromises = Object.values(manifest.components).map(
    async (entry) => {
      try {
        await import(/* @vite-ignore */ `@plugins/${entry.file}`)
      } catch {
        // Ignore failures during preload
      }
    }
  )

  await Promise.allSettled(loadPromises)
}
