/**
 * Plugin Component Loader
 *
 * Loads pre-built Vue components from the plugins directory at runtime.
 * Components are built by the plugin build script (plugins/build.ts)
 * and output to plugins/{plugin}/dist/{component}.js
 *
 * Plugins are loaded dynamically without needing to be known at build time.
 */

import { defineAsyncComponent, h, type Component } from "vue"

// Component info within a plugin (from plugins.json)
export interface ComponentInfo {
  blockId: string
  blockName: string
  file: string
  icon?: string
  description?: string
}

// Plugin entry in plugins.json
export interface PluginEntry {
  id: string
  name: string
  version: string
  type: "view" | "theme" | "integration"
  manifest: Record<string, unknown>
  components: Record<string, ComponentInfo>
}

// Unified plugins manifest (generated by build script)
export interface PluginsManifest {
  version: string
  buildTime: string
  plugins: PluginEntry[]
}

// Flattened component entry for easier lookup
export interface FlatComponentEntry {
  pluginId: string
  pluginName: string
  pluginVersion: string
  blockId: string
  blockName: string
  file: string
  icon?: string
  description?: string
}

// Cache for loaded manifest and flattened components
let manifestCache: PluginsManifest | null = null
let manifestLoadPromise: Promise<PluginsManifest | null> | null = null
let flatComponentsCache: Map<string, FlatComponentEntry> | null = null

// Track which plugin CSS files have been loaded
const loadedPluginStyles = new Set<string>()

// Base path for plugins (served by Vite middleware in dev, or static files in prod)
const PLUGINS_BASE = "/plugins"

/**
 * Load CSS for a plugin if not already loaded
 */
function loadPluginStyles(pluginId: string, filePath: string): void {
  if (loadedPluginStyles.has(pluginId)) {
    return
  }

  // Extract plugin directory from file path (e.g., "weather-api/dist/weather.js" -> "weather-api")
  const pluginDir = filePath.split("/")[0]

  // Try to load the plugin's CSS file
  const cssUrl = `${PLUGINS_BASE}/${pluginDir}/dist/plugins.css`

  // Create a link element
  const link = document.createElement("link")
  link.rel = "stylesheet"
  link.href = cssUrl
  link.setAttribute("data-plugin-styles", pluginId)

  // Add error handler to silently fail if CSS doesn't exist
  link.onerror = () => {
    console.debug(`No CSS file found for plugin: ${pluginId}`)
    loadedPluginStyles.add(pluginId) // Mark as attempted to avoid retrying
  }

  link.onload = () => {
    console.debug(`Loaded CSS for plugin: ${pluginId}`)
    loadedPluginStyles.add(pluginId)
  }

  document.head.appendChild(link)
}

/**
 * Load the plugins manifest via fetch (runtime loading)
 * In dev mode, loads from glob-based dev loader instead of plugins.json
 */
async function loadManifest(): Promise<PluginsManifest | null> {
  if (manifestCache) {
    return manifestCache
  }

  if (manifestLoadPromise) {
    return manifestLoadPromise
  }

  manifestLoadPromise = (async () => {
    // In dev mode, use glob-based loader for HMR support
    if (import.meta.env.DEV) {
      try {
        const { getDevManifest, getDevFlatComponents } = await import("./pluginDevLoader")
        manifestCache = getDevManifest()
        flatComponentsCache = getDevFlatComponents()
        console.log(`[dev] Loaded ${manifestCache.plugins.length} plugins via import.meta.glob`)
        return manifestCache
      } catch (err) {
        console.warn("[dev] Failed to load plugins via dev loader, falling back to plugins.json", err)
      }
    }

    try {
      const response = await fetch(`${PLUGINS_BASE}/plugins.json`)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      manifestCache = await response.json()
      // Build flattened components map for quick lookup
      flatComponentsCache = new Map()
      for (const plugin of manifestCache!.plugins) {
        for (const [blockId, comp] of Object.entries(plugin.components)) {
          flatComponentsCache.set(blockId, {
            pluginId: plugin.id,
            pluginName: plugin.name,
            pluginVersion: plugin.version,
            blockId: comp.blockId,
            blockName: comp.blockName,
            file: comp.file,
            icon: comp.icon,
            description: comp.description,
          })
        }
      }
      return manifestCache
    } catch (err) {
      console.warn("Plugin manifest not found. Run 'npm run build' in plugins directory.", err)
      return null
    }
  })()

  return manifestLoadPromise
}

/**
 * Get flattened component entries for lookup
 */
async function getComponentsMap(): Promise<Map<string, FlatComponentEntry>> {
  await loadManifest()
  return flatComponentsCache || new Map()
}

/**
 * Create a fallback component for when plugins fail to load
 */
function createFallbackComponent(blockType: string, error?: string): Component {
  return {
    props: ["config"] as const,
    setup(props: { config?: Record<string, unknown> }) {
      return () =>
        h("div", { class: "custom-block plugin-fallback-block" }, [
          h("div", { class: "block-header" }, [
            h("span", { class: "block-icon" }, "⚠️"),
            h("span", { class: "block-title" }, `${blockType} Block`),
          ]),
          h("div", { class: "block-content" }, [
            h("div", { class: "block-note" }, [
              h(
                "em",
                {},
                error ||
                  "Plugin component not available. Run 'npm run build' in the plugins directory.",
              ),
            ]),
            props.config &&
              h("pre", { class: "config-preview" }, JSON.stringify(props.config, null, 2)),
          ]),
        ])
    },
  }
}

/**
 * Create a loading component
 */
const LoadingComponent: Component = {
  setup() {
    return () => h("div", { class: "custom-block loading-block" }, "Loading plugin...")
  },
}

/**
 * Load a plugin component by block type
 *
 * @param blockType - The block type (e.g., "weather", "link-preview")
 * @returns A Vue component (async) that renders the block
 */
export function loadPluginComponent(blockType: string): Component {
  return defineAsyncComponent({
    loader: async () => {
      // In dev mode, use glob loader (full HMR, no build needed)
      if (import.meta.env.DEV) {
        try {
          const { getDevComponentLoader } = await import("./pluginDevLoader")
          const loader = getDevComponentLoader(blockType)
          if (loader) {
            const module = await loader()
            return (module.default || module) as Component
          }
        } catch (err) {
          console.warn(`[dev] Failed to load component via glob for ${blockType}:`, err)
        }
      }

      // Production path: load from manifest + compiled JS
      const componentsMap = await getComponentsMap()
      const entry = componentsMap.get(blockType)

      if (entry) {
        // Load the plugin's CSS file
        loadPluginStyles(entry.pluginId, entry.file)

        // Load the compiled component via dynamic import with full URL
        const moduleUrl = `${PLUGINS_BASE}/${entry.file}`
        try {
          const module = await import(/* @vite-ignore */ moduleUrl)
          return module.default || module
        } catch (err) {
          console.error(`Failed to load compiled component for ${blockType}:`, err)
          // Fall through to fallback
        }
      }

      // Return fallback component
      return createFallbackComponent(blockType)
    },
    errorComponent: createFallbackComponent(blockType, "Failed to load component"),
    loadingComponent: LoadingComponent,
    delay: 200,
    timeout: 10000,
  })
}

/**
 * Get all available block types from loaded plugins
 */
export async function getAvailableBlockTypes(): Promise<
  Array<{
    blockType: string
    pluginId: string
    pluginName: string
    icon?: string
    description?: string
  }>
> {
  const componentsMap = await getComponentsMap()

  return Array.from(componentsMap.values()).map((entry) => ({
    blockType: entry.blockId,
    pluginId: entry.pluginId,
    pluginName: entry.pluginName,
    icon: entry.icon,
    description: entry.description,
  }))
}

/**
 * Check if a block type is available
 */
export async function isBlockTypeAvailable(blockType: string): Promise<boolean> {
  const componentsMap = await getComponentsMap()
  return componentsMap.has(blockType)
}

/**
 * Preload all plugin components (for faster rendering)
 */
export async function preloadPluginComponents(): Promise<void> {
  // In dev mode, preload via glob loaders (Vite handles CSS from .vue files)
  if (import.meta.env.DEV) {
    const { getDevFlatComponents, getDevComponentLoader } = await import("./pluginDevLoader")
    const devComponents = getDevFlatComponents()
    const loadPromises = Array.from(devComponents.keys()).map(async (blockId) => {
      const loader = getDevComponentLoader(blockId)
      if (loader) {
        try {
          await loader()
        } catch {
          // Ignore failures during preload
        }
      }
    })
    await Promise.allSettled(loadPromises)
    return
  }

  const componentsMap = await getComponentsMap()

  if (componentsMap.size === 0) {
    return
  }

  // Track unique plugins to load CSS for each plugin once
  const uniquePlugins = new Map<string, string>() // pluginId -> file path
  Array.from(componentsMap.values()).forEach((entry) => {
    if (!uniquePlugins.has(entry.pluginId)) {
      uniquePlugins.set(entry.pluginId, entry.file)
    }
  })

  // Preload CSS for all plugins
  uniquePlugins.forEach((filePath, pluginId) => {
    loadPluginStyles(pluginId, filePath)
  })

  // Preload component modules
  const loadPromises = Array.from(componentsMap.values()).map(async (entry) => {
    const moduleUrl = `${PLUGINS_BASE}/${entry.file}`
    try {
      await import(/* @vite-ignore */ moduleUrl)
    } catch {
      // Ignore failures during preload
    }
  })

  await Promise.allSettled(loadPromises)
}

// Theme type exposed from plugins
export interface PluginTheme {
  id: string
  name: string
  label: string
  description: string
  className: string
  category: string
  version: string
  stylesheet?: string
}

// View type exposed from plugins
export interface PluginView {
  id: string
  name: string
  description: string
  icon?: string
  pluginId: string
  pluginName: string
}

/**
 * Get all available themes from loaded plugins
 */
export async function getAvailableThemes(): Promise<PluginTheme[]> {
  const manifest = await loadManifest()

  if (!manifest) {
    return []
  }

  const themes: PluginTheme[] = []

  for (const plugin of manifest.plugins) {
    if (plugin.type === "theme" && plugin.manifest.theme) {
      const themeConfig = plugin.manifest.theme as {
        display_name?: string
        category?: string
        className?: string
        stylesheet?: string
      }
      themes.push({
        id: plugin.id,
        name: plugin.id,
        label: themeConfig.display_name || plugin.name,
        description: (plugin.manifest.description as string) || "",
        className: themeConfig.className || `theme-${plugin.id}`,
        category: themeConfig.category || "light",
        version: plugin.version,
        stylesheet: themeConfig.stylesheet,
      })
    }
  }

  return themes
}

/**
 * Get all available views from loaded plugins
 */
export async function getAvailableViews(): Promise<PluginView[]> {
  const manifest = await loadManifest()

  if (!manifest) {
    return []
  }

  const views: PluginView[] = []

  for (const plugin of manifest.plugins) {
    const manifestViews = plugin.manifest.views as
      | Array<{
          id: string
          name: string
          description?: string
          icon?: string
        }>
      | undefined

    if (manifestViews && Array.isArray(manifestViews)) {
      for (const view of manifestViews) {
        views.push({
          id: view.id,
          name: view.name,
          description: view.description || "",
          icon: view.icon,
          pluginId: plugin.id,
          pluginName: plugin.name,
        })
      }
    }
  }

  return views
}

/**
 * Get the stylesheet URL for a theme
 */
export function getThemeStylesheetUrl(themeId: string, stylesheet?: string): string {
  if (stylesheet) {
    return `${PLUGINS_BASE}/${themeId}/${stylesheet}`
  }
  return `${PLUGINS_BASE}/${themeId}/styles/main.css`
}
