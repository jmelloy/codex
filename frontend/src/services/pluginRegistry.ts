/**
 * Plugin Registry Service
 *
 * Registers plugins with the backend on app startup.
 * Plugins are discovered from the plugins.json manifest file generated by
 * the plugin build script (plugins/build.ts).
 */

import api from "./api"

/**
 * Plugin registration request
 */
export interface PluginRegistration {
  id: string
  name: string
  version: string
  type: "view" | "theme" | "integration"
  manifest: Record<string, unknown>
}

/**
 * Plugin registration response
 */
export interface PluginRegistrationResponse {
  id: string
  name: string
  version: string
  type: string
  registered: boolean
  message: string
}

/**
 * Batch registration response
 */
export interface BatchRegistrationResponse {
  registered: number
  updated: number
  failed: number
  results: PluginRegistrationResponse[]
}

/**
 * Plugins manifest structure (generated by build script)
 */
interface PluginsManifest {
  version: string
  buildTime: string
  plugins: PluginRegistration[]
}

// Base path for plugins (served by Vite middleware in dev, or static files in prod)
const PLUGINS_BASE = "/plugins"

// Cache for loaded plugins
let pluginsCache: PluginRegistration[] | null = null
let pluginsLoadPromise: Promise<PluginRegistration[]> | null = null

/**
 * Load plugins from the plugins.json manifest.
 * In dev mode, loads from glob-based dev loader instead.
 */
async function loadPlugins(): Promise<PluginRegistration[]> {
  if (pluginsCache) {
    return pluginsCache
  }

  if (pluginsLoadPromise) {
    return pluginsLoadPromise
  }

  pluginsLoadPromise = (async () => {
    // In dev mode, use glob-based loader
    if (import.meta.env.DEV) {
      try {
        const { getDevManifest } = await import("./pluginDevLoader")
        const manifest = getDevManifest()
        pluginsCache = manifest.plugins.map((p) => ({
          id: p.id,
          name: p.name,
          version: p.version,
          type: p.type,
          manifest: p.manifest,
        }))
        console.log(`[dev] Loaded ${pluginsCache.length} plugins for registration via import.meta.glob`)
        return pluginsCache
      } catch (err) {
        console.warn("[dev] Failed to load plugins via dev loader, falling back to plugins.json", err)
      }
    }

    try {
      const response = await fetch(`${PLUGINS_BASE}/plugins.json`)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`)
      }
      const manifest: PluginsManifest = await response.json()
      pluginsCache = manifest.plugins
      console.log(`Loaded ${manifest.plugins.length} plugins from plugins.json (built ${manifest.buildTime})`)
      return pluginsCache
    } catch (err) {
      console.warn("Plugin manifest not found. Run 'npm run build' in plugins directory.", err)
      return []
    }
  })()

  return pluginsLoadPromise
}

class PluginRegistryService {
  private registered = false
  private registrationPromise: Promise<BatchRegistrationResponse> | null = null

  /**
   * Register all plugins with the backend.
   * This should be called during app initialization.
   * Safe to call multiple times - will only register once.
   */
  async registerPlugins(): Promise<BatchRegistrationResponse> {
    if (this.registered) {
      return {
        registered: 0,
        updated: 0,
        failed: 0,
        results: [],
      }
    }

    if (this.registrationPromise) {
      return this.registrationPromise
    }

    this.registrationPromise = this._doRegister()

    try {
      const result = await this.registrationPromise
      this.registered = true
      return result
    } finally {
      this.registrationPromise = null
    }
  }

  private async _doRegister(): Promise<BatchRegistrationResponse> {
    try {
      const plugins = await loadPlugins()

      if (plugins.length === 0) {
        console.warn("No plugins found to register")
        return {
          registered: 0,
          updated: 0,
          failed: 0,
          results: [],
        }
      }

      const response = await api.post<BatchRegistrationResponse>(
        "/api/v1/plugins/register-batch",
        { plugins }
      )
      console.log(
        `Plugins registered: ${response.data.registered} new, ${response.data.updated} updated, ${response.data.failed} failed`
      )
      return response.data
    } catch (error) {
      console.error("Failed to register plugins with backend:", error)
      const plugins = pluginsCache || []
      // Return empty result on failure - plugins will work in frontend-only mode
      return {
        registered: 0,
        updated: 0,
        failed: plugins.length,
        results: [],
      }
    }
  }

  /**
   * Get the list of plugins.
   * Note: This is async since plugins are loaded from plugins.json
   */
  async getPlugins(): Promise<PluginRegistration[]> {
    const plugins = await loadPlugins()
    return [...plugins]
  }

  /**
   * Get the list of plugins (sync version).
   * Returns cached plugins or empty array if not yet loaded.
   * @deprecated Use getPlugins() instead for guaranteed results
   */
  getKnownPlugins(): PluginRegistration[] {
    return pluginsCache ? [...pluginsCache] : []
  }

  /**
   * Get plugins by type.
   * Note: This is async since plugins are loaded from plugins.json
   */
  async getPluginsByType(type: "view" | "theme" | "integration"): Promise<PluginRegistration[]> {
    const plugins = await loadPlugins()
    return plugins.filter((p) => p.type === type)
  }

  /**
   * Check if a plugin is known by the frontend.
   * Note: This is async since plugins are loaded from plugins.json
   */
  async isPluginKnown(pluginId: string): Promise<boolean> {
    const plugins = await loadPlugins()
    return plugins.some((p) => p.id === pluginId)
  }
}

// Export singleton instance
export const pluginRegistry = new PluginRegistryService()
